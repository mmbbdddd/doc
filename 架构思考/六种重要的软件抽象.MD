### 程序 = 输出/输入 + 状态+ 符号表
https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA
![img.png](../img/图灵机.png)

从形式上看，图灵机 = 输出入+有限状态机+知识库

    1，人工智能是否永远不能超越只是既有知识的组合？
    2，有限和无限
    2，输入信息有两大类：充分信息和不充分信息。
           从输出角度讲，程序是确定性的，收敛的。
           充分信息的输入是足够的，程序是输入和输出之间的一个明确清晰的映射关系。
           不充分信息的输入是欠缺的。程序是呈现高度的摘要收敛能力。例如从只有猫的一个耳朵的相片，判断出猫。
 

### 程序 = 数据 + 逻辑
结构化编程时期的经典抽象。


### 程序 = 对象 + 消息
对象编程时期的经典抽象。

其中对象= 数据 + 逻辑————这并不仅仅是排列组合或者文字游戏。注意：消息这个概念在上一个抽象（数据+逻辑）中并不存在————
上者是对程序实现本身的结构的抽象。而面向对象是对所要解决的问题领域的抽象。

    消息 = 关系 = 问题领域概念的关系
    对象 = 问题领域概念（的属性和行为）

因此，在问题表现能力，面向对象相比之前要强的多。最关键的，是其思考和设计方式不一样了。
在结构化编程之中，开发过程是

    1，设计流程图
    2，根据流程图实现功能

在面向对象开发过程中，是这样的

    1，设计流程图
    2，设计对象
    3，使用事件消息串联对象

这并非仅仅对之前概念做个名词替换。因为在面向对象的核心设计思想中，有一个很少有人强调提却非常重要的概念：不可变性
————对象本身是不变的，它可以把所有它的变化表现为它的属性和方法，而变化本身对外部透明不可见。

理解一下发明了面向对象概念的老爷子运用这套思想设计的的MVC。他嘴巴里的对象根本不是开发理解的那个class或者object，
他嘴巴里的对象更接近于我们理解的领域模型。 

基于对象的这种不可变设计，由此可以积木式的构造复杂的软件大厦。

    本质上，面向对象开发，模块化开发。。。。。都是同一种东西。区别在于，他们的表现形态不同。同样一种架构设计，在对
    延迟更好的游戏领域、就必须做模块化，表现为sdk；在对延迟更不敏感的应用系统中，就表现为微服务架构。

    在架构图中，无论是层次图、类图、模块图、还是应用架构图。。。。。是同质的。不同的人设计的形式上有差别，语义上
    是同一个。
    一般而言，我们在架构设计上追求最低的复杂度，所以仅提及面向对象设计即可。在实施上，追求最小知识原则，所以受众
    理解什么我们说什么。

### 程序 = 实体 + 值对象   
在2003年，领域驱动理论明确提出了：实体、值对象、聚合、仓储工厂、防腐层这种新的抽象。

在此之前，软件架构设计领域可以认为是在盲人摸象般摸索。

1960年代，Unit设计的时候，PM向开发麦克罗伊提了管道的设计，先后被开发麦克罗伊几个月内拒绝了三四次；直到有一天他睡梦
中突然蹦起来去完成了这个设计。

虽然Unix之后因为优雅总结了Kiss，并出版了《unix设计哲学》，可是具体简单到什么程度才是简单，一直保持object才是最简
单么？大多数时候，这句话是懒惰的开发为自己找的借口。

在Unix之后，各种架构设计理论满天飞，可是几乎上没有什么架构理论能产生什么伟大的工程、伟大的软件、甚至连优秀和成功的案例
都很少。有真正有效果的一些更接近于特定领域的方案设计实践，而不是一种通用的架构设计方法论。比如OO，比如函数式，比如JEE
比如2003年亚马逊通过贝索斯颁布所有程序必须通过API交互——最终产生了亚马逊云......

而往往这些成功实践也很难总结出可复制的、通用的架构理论。 这些架构理论甚至远不如经验丰富的老开发的很多只言片语有用。比如

        程序中最重要的设计是数据结构的设计
        SOLID

大部分时候，这些只言片语非常晦涩。比如大概有10多年我对“数据结构”的理解就跑到了链表、树、网等数据结构上来了。

在领域驱动里面，不但通过一种设计理论将问题域到程序设计怎么做解决了，也解决了架构设计到代码实现之间的关系。

    1，实体是对世界的无限性的抽象，用ID来代表他
    2，值对象广义上是对程序的有限性的抽象，用CODE来代表他
    3，值对象狭义上（架构设计上）是对变化的抽象，在C语言中表现为数据结构，在对象语言中表现为值对象数据。在表现形式
    上，可能是代码、配置文件、配置表
    4，聚合是对象之间关系   

### 软件工程复杂度 = 本质复杂度 + 偶然复杂度
本质复杂度/偶然是brooks在70年前提到的概念。
前者代表一个问题领域的最低复杂度
后者代表我们在工程实现中增加的各种复杂度

如同热力学守恒一样，在架构设计中同样存在“复杂度守恒”

    本质复杂度守恒 
    偶然复杂度增加并永远不为0

所以，KISS之所以不对，是因为有些事物就是复杂的、掩饰其复杂度的设计只能让其变得更复杂。所以，虽然相对论相比牛顿三定律要复杂很多倍。
可他依然比牛顿三定律更美；因为其背后包含的问题域的复杂度要远远超过前者。简单和复杂只是相对于问题域而言————其每个符号所包含的信息密度
要远超其他解决方案————抛开问题域的简单毫无意义。

在整个软件工程的各个环节都充斥了各种熵

    1，设计熵：设计不够通用、或者过度设计、设计的过于复杂
    2，开发流程熵：不该用的用了。。。。。该用敏捷的用了瀑布、该用瀑布的用了敏捷……
    3，组织架构熵：
    4，技术熵：


###  信息 = 架构

一个输入/输出有清晰明确映射去关系且的架构在数学上是收敛的。

    这种收敛结构就是他的架构； 
    在系统论上，即自组织系统
    在热力学上，即熵减系统； 
    薛定谔说：熵减即生命。

这种收敛结构在视觉上呈现一颗以流程为核心的树状和网状架构
这种收敛结构在数据上呈现就是聚合根。聚合根决定了这种收敛系统的架构。
聚合根是一个系统感知的外界输入的信息。

    树状结构：普通程序（完全信息架构）
    网状结构：人工智能、大脑（不完全信息架构）
    盖亚
 


