### 程序 = 输出/输入 + 状态+ 符号表
https://zh.wikipedia.org/wiki/%E5%9B%BE%E7%81%B5%E6%9C%BA
![img.png](../img/图灵机.png)

从形式上看，图灵机 = 输出入+有限状态机+知识库

    1，人工智能是否永远不能超越只是既有知识的组合？
    2，有限和无限
    2，输入信息有两大类：充分信息和不充分信息。
           从输出角度讲，程序是确定性的，收敛的。
           充分信息的输入是足够的，程序是输入和输出之间的一个明确清晰的映射关系。
           不充分信息的输入是欠缺的。程序是呈现高度的摘要收敛能力。例如从只有猫的一个耳朵的相片，判断出猫。
 

### 程序 = 数据 + 逻辑
结构化编程时期的经典抽象。


### 程序 = 对象 + 消息
对象编程时期的经典抽象。

其中对象= 数据 + 逻辑————这并不仅仅是排列组合或者文字游戏。注意：消息这个概念在上一个抽象（数据+逻辑）中并不存在————
上者是对程序实现本身的结构的抽象。而面向对象是对所要解决的问题领域的抽象。

    消息 = 关系 = 问题领域概念的关系
    对象 = 问题领域概念（的属性和行为）

因此，在问题表现能力，面向对象相比之前要强的多。最关键的，是其思考和设计方式不一样了。
在结构化编程之中，开发过程是

    1，设计流程图
    2，根据流程图实现功能

在面向对象开发过程中，是这样的

    1，设计流程图
    2，设计对象
    3，使用事件消息串联对象

这并非仅仅对之前概念做个名词替换。因为在面向对象的核心设计思想中，有一个很少有人强调提却非常重要的概念：不可变性
————对象本身是不变的，它可以把所有它的变化表现为它的属性和方法，而变化本身对外部透明不可见。

理解一下发明了面向对象概念的老爷子运用这套思想设计的的MVC。他嘴巴里的对象根本不是开发理解的那个class或者object，
他嘴巴里的对象更接近于我们理解的领域模型。 

基于对象的这种不可变设计，由此可以积木式的构造复杂的软件大厦。

    本质上，面向对象开发，模块化开发。。。。。都是同一种东西。区别在于，他们的表现形态不同。同样一种架构设计，在对
    延迟更好的游戏领域、就必须做模块化，表现为sdk；在对延迟更不敏感的应用系统中，就表现为微服务架构。

    在架构图中，无论是层次图、类图、模块图、还是应用架构图。。。。。是同质的。不同的人设计的形式上有差别，语义上
    是同一个。
    一般而言，我们在架构设计上追求最低的复杂度，所以仅提及面向对象设计即可。在实施上，追求最小知识原则，所以受众
    理解什么我们说什么。

### 程序 = 实体 + 值对象   

理论上，OO诞生以后，就能解决了复杂软件的架构设计问题————理论上是这样的。实际上绝大多数人并不理解OO(D)，而只再用OOP。

领域驱动解决了从OOD到OOP的架构治理的问题

    1，如何构建概念完整性
    
    2，基于概念完整性，构建领域模型；基于领域模型，构建核心架构设计；基于核心架构，开发业务代码
    
    3，也许不是所有的业务领域都存在一个通用的领域模型，但是在如何写代码这件事上，的确存在一个通用的领域模型。

事实上，不谈概念完整性——这一点在大部分项目的实践中是事实上根本不是障碍————大部分系统都是遗留系统、都有数年数十年的老员工、业务变更也并不频繁
员工对业务知识的掌握程度也比较完整，并不存在所谓概念完整性的障碍。也并不是所谓的开发流程不够标准的问题。很多公司有非常完善科学的开发比如华为，
可以从概念完整性、到设计、到工程协调都做的很完美。

但是，稍微复杂一点的软件，就非常容易调入复杂度的泥潭之中。他有可能

1，在还没有开发完成已经让项目组崩溃了，比如Multics项目（他的概念图景是完整的、可行的）

2，在开发完整之后，随着需求增加，软件健壮性、可靠性降低而最终崩溃

所以，有经验的开发者并不像年轻人那么激情拥抱新技术和业务需求：
举两个例子 
1960年代，Unit的项目经理向开发麦克罗伊提了管道的设想，这个需求被开发麦克罗伊几个月 内拒绝了三四次；直到有一天他睡梦中突然蹦起来去完成了这个设计。

我身边最典型的孵化系统他们的PM是这样操作的： “产品给你提10个需求，你必须拒绝掉 5、6个； 再实现3、4个简单的，再挑一个极其不合理的帮他们实现……这样
对谁都有的交代了”。

面对CTO强令必须进行中台化改造；他们把系统改个名字，或者把灰度、蓝绿等内容塞进来充数。 这背后并不是他们的懒惰、恶意对抗和胆大妄为，（那个分组经理性格相当
温和、圆融），而是因为他们过去无数次努力失败的绝望————所以他们在中台改造方案PPT的第一页就写了version5；然后塞进去了一大堆敷衍了事的内容。

我看过他们过去的架构规划，架构规划图看起来很好、设计很详细、看起来可行性和成功率很高、可是每次最终都失败了。

    技术主导、引入或者发明新轮子、实验新框架。增加技术复杂度
    业务主导、不信任技术、技术僵化理解实现、系统耦合性很高、适应性很窄。
    放弃治疗、抛开老框架、多建微服务。

**事实上，决定大多数软件架构成败的，是开发基本功的匮乏**

——————开发写出来的代码，跟设计图上的根本是两回事。不夸张的讲99%的开发自己的代码和自己的设计都是两回事。
——————1我认为最重要的是，反复琢磨图，做到图完美；一方面反复琢磨代码，图码一体（宏观完美）
——————2少部分情况，开发只能做到代码细节完美（已经是少数情况，有追求的开发了)，这种谈不上设计；但可以指导下做领域开发。
——————3大部分情况，开发只能功能完成（这种只能做业务开发了）
12我认为是制约大部分软件质量最重要的基本因素。这个做不到，谈架构设计很容易空中楼阁。

具体做法参见[《领域驱动：代码角色模型》](领域驱动：代码角色模型.MD)  

### 软件 = 容器 + 组件 +胶水




### 软件工程复杂度 = 本质复杂度 + 偶然复杂度
本质复杂度/偶然是brooks在70年前提到的概念。
前者代表一个问题领域的最低复杂度
后者代表我们在工程实现中增加的各种复杂度

如同热力学守恒一样，在架构设计中同样存在“复杂度守恒”

    本质复杂度守恒 
    偶然复杂度增加并永远不为0

所以，KISS之所以不对，是因为有些事物就是复杂的、掩饰其复杂度的设计只能让其变得更复杂。所以，虽然相对论相比牛顿三定律要复杂很多倍。
可他依然比牛顿三定律更美；因为其背后包含的问题域的复杂度要远远超过前者。简单和复杂只是相对于问题域而言————其每个符号所包含的信息密度
要远超其他解决方案————抛开问题域的简单毫无意义。

在整个软件工程的各个环节都充斥了各种熵

    1，设计熵：设计不够通用、或者过度设计、设计的过于复杂
    2，开发流程熵：不该用的用了。。。。。该用敏捷的用了瀑布、该用瀑布的用了敏捷……
    3，组织架构熵：
    4，技术熵：


###  信息 = 架构

一个输入/输出有清晰明确映射去关系且的架构在数学上是收敛的。

    这种收敛结构就是他的架构； 
    在系统论上，即自组织系统
    在热力学上，即熵减系统； 
    薛定谔说：熵减即生命。

这种收敛结构在视觉上呈现一颗以流程为核心的树状和网状架构
这种收敛结构在数据上呈现就是聚合根。聚合根决定了这种收敛系统的架构。
聚合根是一个系统感知的外界输入的信息。

    树状结构：普通程序（完全信息架构）
    网状结构：人工智能、大脑（不完全信息架构）
    盖亚


