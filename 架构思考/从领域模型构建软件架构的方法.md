### 概述

领域驱动理论落地大致遵循这样一个流程

流程：领域学习》事件风暴》领域驱动代码模型》领域落地方法论


### 领域学习

在1960年的时候，brooks在os360项目中已经认识到：阻碍软件设计的最大困难是构建“概念完整性”，但截止到2003年领域驱动理论
诞生之前，尽管有很多架构方法论，比如《Unix设计哲学》《Jee设计哲学》，KISS，SOILD，瀑布，TOGAF.....然而他们要么是
在停留在意图表达阶段、要么只是在操作、步骤上。。。没有一个架构理论解决了这个根本问题。


正如《人月神话：软件的根本困难》章节所描述的那样


    软件的根本困难不是语言语法、不是类库.....而是软件简化到极致是一些概念和概念之间的关系。而这本身就是极其复杂的（参考三体、混沌等数学理论）


除了数学上的限制以外，在具体操作上也概念完整性业具有极大的调整

    1，不可能从一线人员的知识汇总中形成领域模型—————因为无法定义足够的需求样本在哪里。
    2，也不可能从理论或者书本上获得实际工厂的领域架构————大部分工业软件和书本理论都相差很远 ，没有什么商业软件是来自于书本的，它们是通常是非常复杂的多种复杂领域的混合体。


聚合根解决了这个问题。他的原理相当简单

    大树的每个枝叶分叉都必然和根相连；软件架构通常是一个不停分叉的逻辑树、而每个分叉同样逻辑上和一个根相连——聚合根。聚合根决定架构形状 

一般上软件的聚合根就是他的实体对象。例如一个支付系统的聚合根可能是这样的。

    pay_trade_order
    卖家：mall_id;ID
    卖家类型：普通小商家，VIP付费小商家，大客户、VIP付费大客户.....:枚举值对象
    买家ID：user_id:ID
    买家类型：穷鬼/穷人VIP/有钱人/有钱人且舍得花钱的VIP。。。。。。:枚举值对象
    支付金额：amount：数据类型
    支付渠道：alipay，weixinPay，abc，psbc，.....：枚举值对象

有意思是《领域驱动》这一突破性的理论认识，然而他在书中表达的非常含糊。我猜测这可能和他开销售公司有关系。


### 事件风暴

   1，从操作上，聚合根的获取一般是用过数据库，这只有在遗留系统中可以这么操作
   
   2，在新系统上，一般很难这么操作，新系统获取聚合根的方法是：用例设计+流程分析+事件风暴
   
   3，从事件线上，1方法适用于历史，2方法也适用于未来。


### 领域驱动设计

在领域驱动中，只要设计确定了，代码是存在一个模板式的最佳实践的：实体、值对象、聚合、仓储工厂、防腐层。

然而在我得实践中发现，即使已经存在一个相当固话的最佳实践，在面临各种情况的时候依然会让代码显得相当复杂。代码写着写着就可能距离理想的样子差距较远。

所以在代码的实现上，一般是逆序的————并不遵循ORM思想中先O后R的顺序，先灵活性高的代码再灵活性低的数据库、模块等。而是需要反过来。

我得顺序一般是：ER==》MVP原型 ===》模块==》细节



#### 数据架构
所有的数据库表有三种身份：业务流水表、配置表、其他。
比如支付系统中

| Syntax           | Description |
|------------------|-------------|
| trade_type       | 配置表         |
| trade_order      | 流水表         |
| pay_channel      | 配置表         | 
| dicts            | 其他          |
| trade_order_logs | 其他          | 
| citys            | 其他          | 


所有高频变化的东西，都应该设计到配置文件或者配置表中。 
何谓高频变化：低于或者接近于一个发布周期的就是高频变化。

配置表的本质并不是数据，而是代码。
其做成了配置，必然是需要一个东西来导入、组装成代码的。（参见vof项目）



#### 分层结构/应用架构  


#### 接口设计  
### 架构落地 
#### 对象流程图 
#### 测试驱动
#### 图码一体
#### 重构1：技术和业务分离
#### 重构2：变化和不变分离（值对象）
#### 重构3：回到大气层：适应分层架构和应用架构
