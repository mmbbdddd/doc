1，数字世界有两种抽象：有限和无限——————ID 和 CODE

2，一个接口，承担了两个基本的职能
    
    数据的封装
    逻辑的封装
    信息方向的封装

3，数据的封装和倒置

    3.1 用户A向系统B下单，提供了卡号，用户ID，金额，密码等。构成了一个订单数据。 可以用orderDto代表，这是数据的封装。
    3.2 系统B向系统C下单，提供了卡号，用户ID，金额，密码等，构成了一个订单数据，可以用orderDto代表，这也是数据的封装
    3.3 系统B向系统C下单，提供了orderDto.id ，系统C运行时回调，获取订单，这样也是数据的封装。
    3.4 系统B向系统C下单，提供了orderDto.id & channelId，系统C运行时回调channel，获取订单，这样还是数据的封装。
    
    区别在哪里。
    1   只有3.4是通用的，其他是绑死的特定系统的
    2   通过id的封装和实际传递数据的封装的差异
        2.1 依赖方向是倒置的
        2.2 id必须依赖于数据先存在


4，逻辑的封装和倒置
    
    4.1 某组件A向系统B提供接口服务  service.doA(request);只适应于特定的服务
    4.2 某组件A向系统B提供接口服务  service.do(code，obj);适应于较多的服务，但B必须按A约定的Code传（B透明）
    4.3 某组件A向系统B提供接口服务  service.do(sceneCode，obj);适应于较多的服务，但B必须感知A的场景并适配到自己的code（A透明）




5，在系统设计中，应该是

变化，依赖不变

实现，依赖抽象

不稳定，依赖稳定

不通用，依赖通用

上层，依赖下层


所以，有时候如果需要根据上面的技巧，设计接口，规范和实现正确的架构边界
例如，是springboot和ESB的思路是和传统的思路违背的，但是符复用的原则。

 