
##  1 依赖关系向容器转移（DIP）


## 2 依赖关系向JVM转移

实现如下语法应该怎么做？

    User.selectTop10();
    user.save()

最简单的做法

    User.selectTop10(){
        return springUtils.getBean(JdbcTemplate).selectPageSize(10);
    }
    User.save(){
        return springUtils.getBean(JdbcTemplate).save(this);
    }
    
复杂的做法Play框架那种基于静态代码生成和织入的，当然最终生成的代码差不多。

    
不论什么做法，需要解决的关键问题是 ：User并非SpringBean。如何接受Spring的DIP依赖反转？

基本原理是：

    1，SpringBean之间DIP注入的前提：依赖关系在容器。
    2，JavabeanDIP注入的前提是：依赖关系在JVM
    3，如何做呢？将依赖关系注入到静态类中。


## 3 依赖关系向上下文转移 

在jenkins，filter-chain……这样的架构中，增删掉一个逻辑组件，对上下游透明无影响。

在交易系统中，能否也实现这样高度积木话、高度可编排 可组合的安全的架构？

可以的。

    技术上流程编排这样的组件可以实现。


流程编排本质上实现了如下几个层面的本质解耦

    1，action接口：实现能力组件的标准化、积木化
    2，状态机：实现语义依赖顺序、因果关系的解耦
    3，payload：实现逻辑和数据的解耦

遗留系统如果向流程编排架构改造的话，如果发现

1，AB两个组件存在依赖关系。可以考虑这个依赖关系的因果顺序，定义好状态来解耦

2，AB两个组件存在数据接口依赖关系，可以考虑数据依赖关系向上下文解耦。

## 这背后更深层次的架构原理
    
       DIP概念中的组件依赖关系向上“转移的上，，可能是容器，也可以是JVM，还可以是上下文。
       这个上的底层抽象 = 参见（罗素悖论、哲学概念自指、数学概念系统轮&混沌） = 整体vs局部中的整体。
            ———即不能形成整体对局部的依赖。
            ———例如，在编译器发展的历史中，一个最重要的改变是去掉goto语句。
            ——去掉了goto语句，则编译器规避了语义上的自指。才有可能进一步做精确的语义分析。
            ——才有可能更大范围的替代人工优化&实现更多程序逻辑。
            ——在架构设计中，一旦完成了抽象（整体），就要规律抽象对局部的依赖。
            ——在架构设计中，一旦完成了整体的定义：流程、全局上下文、……就要
                1，规律整体对局部的依赖
                2，实现局部之间依赖向整体的转移。
    
       DIP向上转移目标是组件之间的依赖被转移，组件之间形成一个单向的、松耦合的、延迟的依赖
            这导致
            1，巨大的工程工作量被解耦，可以并行
            2，复杂的耦合关系被解耦、聚焦到一个很小的领域模型。可以底层本的治理。
    
      治理的方式呢
    
            -  结构上，是少数几个模块
            -  人员上&协作上，最好聚焦到少数核心开发
            -  工程上、四两拨千斤
        

        


