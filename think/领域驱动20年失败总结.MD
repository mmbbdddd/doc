### 大事记

2003 年，埃里克・埃文斯（Eric Evans）发表了具有里程碑意义的著作《领域驱动设计：软件核心复杂性应对之策》（Domain-Driven Design:
Tackling Complexity in the Heart of Software），正式提出了领域驱动设计的概念。

2006 年，吉米・尼尔森（Jimmy Nilsson）在他的著作《Applying Domain-Driven Design and Patterns: With Examples in C#
and.NET》中，将 DDD 和设计模式、重构等概念结合起来，进一步丰富了 DDD 的实践方法。

2007 年，格雷格・杨（Greg Young）提出了 CQRS（Command Query Responsibility Segregation）架构，将 DDD 的概念引入了架构设计，使得
DDD 可以更好地处理大型和复杂的系统。

2011 年，沃恩・弗农（Vaughn Vernon）在他的著作《Implementing Domain-Driven Design》中，进一步深化了 DDD 的实践方法，并提出了聚合设计的新方法。

### 落地实践方法

**与领域专家紧密合作**
你需要积极与业务领域的专家进行沟通和交流，他们对业务流程、规则和概念有着深入的理解。通过与他们合作，可以确保你的软件设计准确地反映了业务需求。
定期组织研讨会、访谈等活动，让领域专家参与到软件设计的过程中，共同探讨和解决问题。

**建立统一语言**
在团队中建立一种统一的业务语言，避免因术语不一致而导致的误解。这种统一语言应该基于领域专家的术语和概念，同时也易于开发人员理解和使用。
将统一语言贯穿于需求分析、设计、开发和测试的各个阶段，确保团队成员之间的沟通顺畅

**明确业务边界**
通过分析业务领域，确定不同的业务模块和功能边界。每个限界上下文代表一个独立的业务领域，具有明确的职责和边界。
避免限界上下文之间的过度耦合，确保每个上下文都可以独立地进行开发、测试和维护
**设计上下文映射**
确定不同限界上下文之间的关系，设计合理的上下文映射。上下文映射可以帮助你理解不同业务模块之间的交互方式，以及如何在软件设计中实现这些交互。
常见的上下文映射方式有共享内核、客户 / 供应商、遵奉者等，根据实际情况选择合适的映射方式。

**确定聚合根**
在每个限界上下文中，确定一个或多个聚合根。聚合根是聚合的核心实体，它负责维护聚合的一致性和完整性。
聚合根应该具有明确的业务含义，并且能够代表整个聚合的状态。

**设计聚合结构**
围绕聚合根设计聚合的结构，包括实体、值对象和领域服务等。实体具有唯一的标识，值对象则是不可变的、用于描述领域概念的对象。
确保聚合内部的对象之间具有高内聚性，同时聚合之间保持低耦合性。

### 实践经验总结

~~* 1，和领域专家紧密合作/建立领域模型~~

0分：
这一条基本是空话。

第一找不到敢自称领域专家的人，即使很多深耕这个行业20+的老业务专家，也不敢号称自己所有细节都懂，都清楚。

很多即使懂的，也难以短时间讲清楚。讲的全是细节。。。。并且永远不能确保完备性……甚至准确性……

**比较关键的信息是：领域驱动概念和思想是基于软件设计本身很多特性产生的……很多业务专家完全没法理解什么是领域。什么是抽象。**

在和领域专家的合作中，架构师必须能够主导

1. 能够很清晰的明确自己想从领域专家哪里希望知道什么
2. 能够很清晰的判断自己需要的内容是否完善，完整，完备，什么时候该终止调研，什么时候改继续细追下去。
3. 能够从业务专家的细节中，获取关键的信息，甚至能引导梳理出来业务专家所没有思考到的关键信息

实际上，这个要求，对99。9%的软件出身的架构师是没有办法满足的。

产品出身的，99%也做不到，相对好一点————但大部分产品经理没法理解架构和抽象到底是什么。

**总之，这一条，是讲了一条正确的，没有办法落地的废话。**

~~* 2，建立统一语言~~

这一条，也没有办法落地，并且意义不大。

某宇宙大行，在做新核心之前，曾经招了200个管培生，花费了3年左右，梳理了全行所涉及的所有字段（大概15w左右），统一和定义了他们的业务含义。

那么，这么庞大的知识，如何在每个人的日常中消化和使用呢？

能对将来的业务，产生什么有效率的收益呢么？

**建立统一语言的前提，是基于领域专家和技术专家的紧密合作。为了达成紧密而准确的沟通，需要精确、清晰的概念定义和界定。**

这个前提，存在么？

它只是一个沟通的手段，目的是为了建立准确、正确的模型。————并且仅靠统一语言是没有办法完全做到的————真正关键的是”事件风暴“——
在流程梳理清晰的基础上，进行端到端的验证+脑暴。

        参见聚合根
        可以很轻量化的做到，并且做的更好。

~~* 3，明确业务边界~~

从70年前到现在，架构的基本思想没有变化、并不是什么新东西————就是模块化，组件化。 只不过不同的时代，组件的粒度有所不同，有所发展。

* 最早是动态链接/静态链接库
* 然后是面向对象
* 中间件
* 现在是微服务。

基本的思想和原则、目标没有大的变化。

当然，不同的形式，其实也有新的差异和问题。其实也有很大的差异，同样的逻辑，实现形式是class，还是app，是以sdk还是微服务的方式提供。性能消耗、使用成本是完全不同的。

| 形式         | 性能成本 | 协作沟通成本 | 复用成本 | 管理组织成本 |
|------------|------|--------|------|--------|
| class/代码复用 | 低    | 高      | 高    | 高      |
| jar/sdk    | 低    | 低      | 低    | 高      |
| api/微服务    | 高    | 高      | 低    | 低      |

        讲个小故事
        核心业务系统需要一个流程编排组件，实现业务的积木化开发，需要是这样的
        1，可以本地解析流程&执行，有比较好的性能，
        2，服务端流程监控，编排和管理流程
        
        架构组不愿意做，他们愿意提供一个纯服务器端运行的流程编排。但是这对开发组，不能接受

        需要思考的问题是：为什么架构组抗拒提供一个jar包而推荐提供一个api微服务呢？

        这就是管理成本。


        微服务的背后是一个个非常独立的团队。他们有很高的独立性，自由度。
        而sdk，似乎纯粹是打工的。别人有很高的自由扩展权，你80%的投入，20%的收益。别人反过来。别人又非强依赖你。

        在这里利益墙之下，你管不了他们，没有办法按最佳的方案去设计和推动。这就是架构方案即组织，组织管理成本即使架构成本。


在05~10左右，SOA发展期间，很多公司的应用数量快速成单体膨胀到数百上千个。然而，后面中台时代，合并掉50%都不可能。

    顺着人性做事，很容易。
    逆着人性做事，很难。
    将来业务发展到某个阶段，如果必须合，不合不行。或者有些部门利益必须割，不割不行。
        然而，这个时候你发现你的部门和你的代码一样，都解耦不清楚，分割不明白。
        这前期泼出去的水，就收不回来了；死路一条。
    
   **划分边界，本质是划分组织架构。系统边界并不是本质，这个可以商量的，可以调的**

~~* 4，设计上下文映射~~

上面我们批判了统一语言那套做法，做的过重。效益不大

其实那套做法的本质和前几年的UML差不多。

现在更推荐的是：

1，整体流程清晰的基础上，局部随意发挥
2，局部对接，如果有gap，定义一套映射结构来协调。

而不是过去那种事前全部规划到，考虑到。

规划的完整性是必要的，但是在交易结构上，关键交易相关方，在主流程上，而不是coner case，业务细节。那永无止境。

* 5，确定聚合根

        今天
        DDD中聚合根的概念更加清晰：
                    信息决定架构，业务逻辑是枝干复杂的大树，
                    聚合根是点，所有枝干都必然和根关联，关联了输入信息中的某个数据。
                    分析清楚了信息架构，就分析清楚额架构。

        所以，在今天，基于聚合根的脑暴，是可以很大概率梳理清楚未来较长实践的业务变化。
                    并且，基于业务，
                    有很高的针对性，有很低的技术熵 


* 6，防腐层设计
    
    基本深入人心。

* 7，值对象/实体对象
    
    值对象有不同的理解
    
    JDK理解的值对象：是不可变对象。

    DDD理解的值得对象：是变化的抽象。

    这两个背后的思想其实是统一的：化变化为不变。
            
 
    这两个抽象背后是软件对整个世界的抽象
    有限性：code
    无限性：id