### 大事记

2003 年，埃里克・埃文斯（Eric Evans）发表了具有里程碑意义的著作《领域驱动设计：软件核心复杂性应对之策》（Domain-Driven Design:
Tackling Complexity in the Heart of Software），正式提出了领域驱动设计的概念。

2006 年，吉米・尼尔森（Jimmy Nilsson）在他的著作《Applying Domain-Driven Design and Patterns: With Examples in C#
and.NET》中，将 DDD 和设计模式、重构等概念结合起来，进一步丰富了 DDD 的实践方法。

2007 年，格雷格・杨（Greg Young）提出了 CQRS（Command Query Responsibility Segregation）架构，将 DDD 的概念引入了架构设计，使得
DDD 可以更好地处理大型和复杂的系统。

2011 年，沃恩・弗农（Vaughn Vernon）在他的著作《Implementing Domain-Driven Design》中，进一步深化了 DDD 的实践方法，并提出了聚合设计的新方法。

### 落地实践方法

**与领域专家紧密合作**
你需要积极与业务领域的专家进行沟通和交流，他们对业务流程、规则和概念有着深入的理解。通过与他们合作，可以确保你的软件设计准确地反映了业务需求。
定期组织研讨会、访谈等活动，让领域专家参与到软件设计的过程中，共同探讨和解决问题。

**建立统一语言**
在团队中建立一种统一的业务语言，避免因术语不一致而导致的误解。这种统一语言应该基于领域专家的术语和概念，同时也易于开发人员理解和使用。
将统一语言贯穿于需求分析、设计、开发和测试的各个阶段，确保团队成员之间的沟通顺畅

**明确业务边界**
通过分析业务领域，确定不同的业务模块和功能边界。每个限界上下文代表一个独立的业务领域，具有明确的职责和边界。
避免限界上下文之间的过度耦合，确保每个上下文都可以独立地进行开发、测试和维护
**设计上下文映射**
确定不同限界上下文之间的关系，设计合理的上下文映射。上下文映射可以帮助你理解不同业务模块之间的交互方式，以及如何在软件设计中实现这些交互。
常见的上下文映射方式有共享内核、客户 / 供应商、遵奉者等，根据实际情况选择合适的映射方式。

**确定聚合根**
在每个限界上下文中，确定一个或多个聚合根。聚合根是聚合的核心实体，它负责维护聚合的一致性和完整性。
聚合根应该具有明确的业务含义，并且能够代表整个聚合的状态。

**设计聚合结构**
围绕聚合根设计聚合的结构，包括实体、值对象和领域服务等。实体具有唯一的标识，值对象则是不可变的、用于描述领域概念的对象。
确保聚合内部的对象之间具有高内聚性，同时聚合之间保持低耦合性。

### 实践经验总结

* 1，和领域专家紧密合作/建立领域模型


    大多数公司并不是缺乏技术专家、也并不是缺乏业务专家。
    也并不是缺乏让业务专家和技术专家一起紧密合作的空间和机制。
    而是不知道使用什么样的方法，让他们在一起聊的时候，能聊到一起，而且能聊出一个炫目的结晶：领域模型。

    



~~* 2，建立统一语言~~
    
    这一条，也没有办法落地，并且意义不大。
    
    某宇宙大行，在做新核心之前，曾经招了200个管培生，花费了3年左右，梳理了全行所涉及的所有字段（大概15w左右），统一和定义了他们的业务含义。
    
    那么，这么庞大的知识，如何在每个人的日常中消化和使用呢？

**建立统一语言的前提，是基于领域专家和技术专家的紧密合作。为了达成紧密而准确的沟通，需要精确、清晰的概念定义和界定。**

    这个前提，存在么？

~~* 3，明确业务边界~~
    
    从70年前到现在，架构的基本思想没有变化、并不是什么新东西————就是模块化，组件化。 只不过不同的时代，组件的粒度有所不同，有所发展。
    
    * 最早是动态链接/静态链接库
      * 然后是面向对象
      * 中间件
      * 现在是微服务。
    
    基本的思想和原则、目标没有大的变化。
    
    当然，不同的形式，其实也有新的差异和问题。其实也有很大的差异，同样的逻辑，实现形式是class，还是app，是以sdk还是微服务的方式提供。性能消耗、使用成本是完全不同的。

| 形式         | 性能成本 | 协作沟通成本 | 复用成本 | 管理组织成本 |
|------------|------|--------|------|--------|
| class/代码复用 | 低    | 高      | 高    | 高      |
| jar/sdk    | 低    | 低      | 低    | 高      |
| api/微服务    | 高    | 高      | 低    | 低      |

        讲个小故事
        核心业务系统需要一个流程编排组件，实现业务的积木化开发，需要是这样的
        1，可以本地解析流程&执行，有比较好的性能，
        2，服务端流程监控，编排和管理流程
        
        架构组不愿意做，他们愿意提供一个纯服务器端运行的流程编排。但是这对开发组，不能接受

        需要思考的问题是：为什么架构组抗拒提供一个jar包而推荐微服务呢？

        微服务的背后是一个个非常独立的团队。他们有很高的独立性，自由度。
        而sdk，似乎纯粹是打工的。别人有很高的自由扩展权，你80%的投入，20%的收益。别人反过来。别人又非强依赖你。


在05~10左右，SOA发展期间，很多公司的应用数量快速成单体膨胀到数百上千个。然而，后面中台时代，却很蹉跎，之前一直顺风顺水锋芒毕露的阿里，从这里开始进入颓势。

    顺着人性做事，很容易。
    逆着人性做事，很难。
    顺着人性的顺利，将来有可能都成为自己的包袱。 
    
   **划分边界，本质是划分组织架构。系统边界并不是本质，这个可以商量的，可以调的；而组织利益不行**

   **现在大量使用微服务的软件公司，未来…………**

~~* 4，设计上下文映射~~



    

* 5，确定聚合根

          信息决定架构，聚合根是业务分析的抓手。
                        譬如，一颗大树，枝繁叶茂。但无论多么繁茂，每一个毛细细节必然通向根。
                        在软件中，同样有这样的关系：某个数据对象，可以映射这个软件的架构形状。
          所以，找到聚合根，分析清楚了聚合根的数据要素和词典，就抓住了整个复杂软件的关键。
                        它同时意味着
                         1，逻辑上存在一个最合理的架构形状和结构。
                         2，架构分析过程，不再容易过度设计，而变得更有目的和针对性

  * 6，防腐层设计


    
      深入人心。
        甚至，我能看到没有任何领域设计的系统中，所有外部调用都有Proxy模式封装。


* 7，值对象/实体对象
    
    值对象有不同的理解
    
    JDK理解的值对象：是不可变对象。

    DDD理解的值得对象：是变化的抽象。

    这两个背后的思想其实是统一的：化变化为不变。
            
 
    这两个抽象背后是软件对整个世界的抽象
    有限性：code
    无限性：id